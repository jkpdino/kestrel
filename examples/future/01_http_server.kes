// A simple HTTP server showing async, pattern matching, and implicits

struct Request {
    let method: String
    let path: String
    let body: Option[String]
}

struct Response {
    let status: Int
    let body: String

    static func ok(body: String) -> Response = Response(status: 200, body: body)
    static func notFound() -> Response = Response(status: 404, body: "Not Found")
    static func badRequest(msg: String) -> Response = Response(status: 400, body: msg)
}

protocol Database {
    async func findUser(id: Int) -> Option[User]
    async func saveUser(user: User) throws
}

given Database = PostgresDatabase(connectionString: "postgres://localhost/app")

async func handleRequest(req: Request) -> Response {
    match (req.method, req.path) {
        ("GET", "/health") => Response.ok("OK")

        ("GET", path) if path.startsWith("/users/") => {
            let id = path.removePrefix("/users/").parseInt() ?? return Response.badRequest("Invalid ID")
            let user = await Database.findUser(id)
            match user {
                Some(u) => Response.ok(u.toJson())
                None => Response.notFound()
            }
        }

        ("POST", "/users") => {
            let body = req.body ?? return Response.badRequest("Missing body")
            let user = User.fromJson(body) ?? return Response.badRequest("Invalid JSON")
            try {
                await Database.saveUser(user)
                Response.ok(user.toJson())
            } catch e {
                Response.badRequest(e.message)
            }
        }

        _ => Response.notFound()
    }
}

func main() {
    given Executor = WorkStealingExecutor(threads: 4)

    let server = HttpServer(port: 8080)

    Executor.block {
        await server.listen { req in
            await handleRequest(req)
        }
    }
}
