// Template for floating-point types
// Placeholders:
//   {{TYPE_NAME}}  - e.g., Float32, Float64
//   {{LANG_TYPE}}  - e.g., lang.f32, lang.f64
//   {{BITS}}       - e.g., 32, 64
//   {{ADD_OP}}     - e.g., lang.f64_add
//   {{SUB_OP}}     - e.g., lang.f64_sub
//   {{MUL_OP}}     - e.g., lang.f64_mul
//   {{DIV_OP}}     - e.g., lang.f64_div
//   {{NEG_OP}}     - e.g., lang.f64_neg
//   {{EQ_OP}}      - e.g., lang.f64_eq
//   {{LT_OP}}      - e.g., lang.f64_lt
//   {{LE_OP}}      - e.g., lang.f64_le
//   {{GT_OP}}      - e.g., lang.f64_gt
//   {{GE_OP}}      - e.g., lang.f64_ge

public struct {{TYPE_NAME}}:
    FloatingPoint,
    Numeric,
    Addable,
    Subtractable,
    Multipliable,
    Divisible,
    Negatable,
    ExpressibleByFloatLiteral,
    ExpressibleByIntLiteral
{
    private var value: {{LANG_TYPE}}

    // Numeric protocol
    public static var zero: {{TYPE_NAME}} { {{TYPE_NAME}}(value: 0.0) }
    public static var one: {{TYPE_NAME}} { {{TYPE_NAME}}(value: 1.0) }

    // FloatingPoint protocol
    public static var infinity: {{TYPE_NAME}} { {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_infinity()) }
    public static var nan: {{TYPE_NAME}} { {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_nan()) }
    public static var bitWidth: Int { {{BITS}} }

    // ExpressibleByFloatLiteral
    public init(floatLiteral value: Float64) {
        self.value = value as {{LANG_TYPE}}
    }

    // ExpressibleByIntLiteral
    public init(intLiteral value: Int) {
        self.value = value as {{LANG_TYPE}}
    }

    // FloatingPoint methods
    public func isNaN() -> Bool {
        lang.{{LANG_TYPE}}_is_nan(self.value)
    }

    public func isInfinite() -> Bool {
        lang.{{LANG_TYPE}}_is_infinite(self.value)
    }

    public func isFinite() -> Bool {
        not self.isNaN() and not self.isInfinite()
    }

    // Equatable
    public func equals(other: {{TYPE_NAME}}) -> Bool {
        {{EQ_OP}}(self.value, other.value)
    }

    // Comparable
    public func compare(other: {{TYPE_NAME}}) -> Ordering {
        if {{LT_OP}}(self.value, other.value) {
            .Less
        } else if {{GT_OP}}(self.value, other.value) {
            .Greater
        } else {
            .Equal
        }
    }

    // Addable
    type Output = {{TYPE_NAME}}

    public func add(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{ADD_OP}}(self.value, other.value))
    }

    // Subtractable
    public func subtract(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{SUB_OP}}(self.value, other.value))
    }

    // Multipliable
    public func multiply(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{MUL_OP}}(self.value, other.value))
    }

    // Divisible
    public func divide(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{DIV_OP}}(self.value, other.value))
    }

    // Negatable
    public func negate() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{NEG_OP}}(self.value))
    }

    // Math operations
    public func abs() -> {{TYPE_NAME}} {
        if {{LT_OP}}(self.value, 0.0) {
            {{TYPE_NAME}}(value: {{NEG_OP}}(self.value))
        } else {
            self
        }
    }

    public func floor() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_floor(self.value))
    }

    public func ceil() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_ceil(self.value))
    }

    public func round() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_round(self.value))
    }

    public func sqrt() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_sqrt(self.value))
    }

    public func pow(exponent: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: lang.{{LANG_TYPE}}_pow(self.value, exponent.value))
    }
}
