// Template for integer types
// Placeholders:
//   {{TYPE_NAME}}  - e.g., Int32, UInt64
//   {{LANG_TYPE}}  - e.g., lang.i32, lang.u64
//   {{SIGNED}}     - true or false
//   {{BITS}}       - e.g., 32, 64
//   {{MIN_VALUE}}  - minimum value for the type
//   {{MAX_VALUE}}  - maximum value for the type
//   {{ADD_OP}}     - e.g., lang.i32_add, lang.u64_add
//   {{SUB_OP}}     - e.g., lang.i32_sub
//   {{MUL_OP}}     - e.g., lang.i32_mul
//   {{DIV_OP}}     - e.g., lang.i32_div
//   {{REM_OP}}     - e.g., lang.i32_rem
//   {{NEG_OP}}     - e.g., lang.i32_neg (only for signed)
//   {{EQ_OP}}      - e.g., lang.i32_eq
//   {{NE_OP}}      - e.g., lang.i32_ne
//   {{LT_OP}}      - e.g., lang.i32_lt
//   {{LE_OP}}      - e.g., lang.i32_le
//   {{GT_OP}}      - e.g., lang.i32_gt
//   {{GE_OP}}      - e.g., lang.i32_ge
//   {{AND_OP}}     - e.g., lang.i32_and
//   {{OR_OP}}      - e.g., lang.i32_or
//   {{XOR_OP}}     - e.g., lang.i32_xor
//   {{NOT_OP}}     - e.g., lang.i32_not
//   {{SHL_OP}}     - e.g., lang.i32_shl
//   {{SHR_OP}}     - e.g., lang.i32_shr or lang.u32_shr

public struct {{TYPE_NAME}}:
    {{SIGNED_PROTOCOL}},
    Numeric,
    Hashable,
    Addable,
    Subtractable,
    Multipliable,
    Divisible,
    Modulo,
    {{NEGATABLE_IMPL}}
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNot,
    LeftShift,
    RightShift,
    ExpressibleByIntLiteral
{
    private var value: {{LANG_TYPE}}

    // Numeric protocol
    public static var zero: {{TYPE_NAME}} { {{TYPE_NAME}}(value: 0) }
    public static var one: {{TYPE_NAME}} { {{TYPE_NAME}}(value: 1) }

    // Integer protocol
    public static var minValue: {{TYPE_NAME}} { {{TYPE_NAME}}(value: {{MIN_VALUE}}) }
    public static var maxValue: {{TYPE_NAME}} { {{TYPE_NAME}}(value: {{MAX_VALUE}}) }
    public static var bitWidth: Int { {{BITS}} }

    // ExpressibleByIntLiteral
    public init(intLiteral value: Int) {
        self.value = value as {{LANG_TYPE}}
    }

    // Equatable
    public func equals(other: {{TYPE_NAME}}) -> Bool {
        {{EQ_OP}}(self.value, other.value)
    }

    // Comparable
    public func compare(other: {{TYPE_NAME}}) -> Ordering {
        if {{LT_OP}}(self.value, other.value) {
            .Less
        } else if {{GT_OP}}(self.value, other.value) {
            .Greater
        } else {
            .Equal
        }
    }

    // Hashable
    public func hash[H: Hasher](into hasher: ref H) {
        hasher.write(bytes: self.value as Slice[UInt8])
    }

    // Addable
    type Output = {{TYPE_NAME}}

    public func add(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{ADD_OP}}(self.value, other.value))
    }

    // Subtractable
    public func subtract(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{SUB_OP}}(self.value, other.value))
    }

    // Multipliable
    public func multiply(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{MUL_OP}}(self.value, other.value))
    }

    // Divisible
    public func divide(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{DIV_OP}}(self.value, other.value))
    }

    // Modulo
    public func mod(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{REM_OP}}(self.value, other.value))
    }

{{NEGATABLE_BODY}}

    // BitwiseAnd
    public func bitwiseAnd(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{AND_OP}}(self.value, other.value))
    }

    // BitwiseOr
    public func bitwiseOr(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{OR_OP}}(self.value, other.value))
    }

    // BitwiseXor
    public func bitwiseXor(other: {{TYPE_NAME}}) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{XOR_OP}}(self.value, other.value))
    }

    // BitwiseNot
    public func bitwiseNot() -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{NOT_OP}}(self.value))
    }

    // LeftShift
    public func shiftLeft(by count: Int) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{SHL_OP}}(self.value, count as {{LANG_TYPE}}))
    }

    // RightShift
    public func shiftRight(by count: Int) -> {{TYPE_NAME}} {
        {{TYPE_NAME}}(value: {{SHR_OP}}(self.value, count as {{LANG_TYPE}}))
    }

{{SIGNED_METHODS}}
}
